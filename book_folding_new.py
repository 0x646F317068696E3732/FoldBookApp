import math
from typing import List, Dict, Tuple

class BookFoldingArtGenerator:
    """
    Настоящий генератор book folding art на основе изученных алгоритмов
    """
    
    def __init__(self):
        # Параметры книги
        self.total_pages = 400      # общее количество страниц
        self.page_height = 200      # высота страницы (мм)
        self.page_width = 120       # ширина страницы (мм) - важно!
        self.fold_inset = 15        # глубина сгиба внутрь от края (мм)
        
        # Параметры качества
        self.min_pages_per_letter = 12  # минимум страниц на букву
        self.min_fold_height = 4        # минимальная высота сгиба (мм)
        
    def set_book_parameters(self, pages: int, height: int, width: int, inset: int):
        """Установить параметры книги"""
        self.total_pages = pages
        self.page_height = height
        self.page_width = width
        self.fold_inset = inset
        
    def text_to_pattern(self, text: str) -> List[Dict]:
        """
        Преобразует текст в паттерн складывания
        Основан на настоящем алгоритме book folding art
        """
        text = text.strip().upper()
        if not text:
            return []
            
        # Поддерживаемые символы
        supported_chars = set('ABCDEFGHIJKLMNOPQRSTUVWXYZАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ0123456789 ')
        clean_text = ''.join(c for c in text if c in supported_chars)
        
        if not clean_text:
            return []
        
        # Рассчитываем доступные четные страницы (правые страницы)
        available_even_pages = self.total_pages // 2
        
        # Подсчитываем символы без пробелов
        letter_count = len([c for c in clean_text if c != ' '])
        
        # Проверяем минимальные требования
        if letter_count == 0:
            return []
            
        # Рассчитываем страниц на символ
        ideal_pages_per_letter = available_even_pages // letter_count
        pages_per_letter = max(self.min_pages_per_letter, min(ideal_pages_per_letter, 25))
        
        # Если не хватает страниц, снижаем качество
        if letter_count * pages_per_letter > available_even_pages:
            pages_per_letter = max(6, available_even_pages // letter_count)
        
        # Генерируем паттерн
        pattern = []
        current_page = 2  # Начинаем с первой четной страницы
        
        for char in clean_text:
            if char == ' ':
                # Пропуск для пробела
                current_page += max(4, pages_per_letter // 3)
                continue
                
            char_folds = self._generate_letter_folds(char, current_page, pages_per_letter)
            pattern.extend(char_folds)
            current_page += pages_per_letter
            
            # Проверяем границы книги
            if current_page > self.total_pages:
                break
        
        return pattern
    
    def _generate_letter_folds(self, letter: str, start_page: int, page_count: int) -> List[Dict]:
        """Генерирует сгибы для одной буквы"""
        folds = []
        
        # Получаем векторную форму буквы
        letter_shape = self._get_letter_shape(letter)
        
        for i in range(page_count):
            page_num = start_page + (i * 2)
            if page_num > self.total_pages:
                break
                
            # Позиция в букве (0.0 - 1.0)
            letter_progress = i / (page_count - 1) if page_count > 1 else 0.5
            
            # Получаем области сгиба для этой позиции
            fold_areas = self._calculate_letter_cross_section(letter_shape, letter_progress)
            
            for start_ratio, end_ratio in fold_areas:
                start_mm = start_ratio * self.page_height
                end_mm = end_ratio * self.page_height
                
                # Валидация размера сгиба
                if end_mm - start_mm >= self.min_fold_height:
                    folds.append({
                        'page': page_num,
                        'start_mm': round(start_mm, 1),
                        'end_mm': round(end_mm, 1),
                        'depth_mm': self.fold_inset
                    })
        
        return folds
    
    def _get_letter_shape(self, letter: str) -> List[Tuple[float, float]]:
        """
        Возвращает векторную форму буквы для book folding
        Координаты от 0.0 до 1.0 (относительно высоты страницы)
        """
        shapes = {
            # Латинские буквы - упрощенные векторные формы
            'A': [(0.1, 0.9), (0.25, 0.1), (0.4, 0.9), (0.15, 0.6), (0.35, 0.6)],
            'B': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.3, 0.5), (0.1, 0.5), (0.3, 0.1), (0.3, 0.9)],
            'C': [(0.4, 0.8), (0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.4, 0.2)],
            'D': [(0.1, 0.9), (0.1, 0.1), (0.3, 0.2), (0.35, 0.8), (0.1, 0.9)],
            'E': [(0.4, 0.9), (0.1, 0.9), (0.1, 0.1), (0.4, 0.1), (0.1, 0.5), (0.3, 0.5)],
            'F': [(0.4, 0.9), (0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.3, 0.5)],
            'G': [(0.4, 0.8), (0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.4, 0.2), (0.4, 0.5), (0.25, 0.5)],
            'H': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.4, 0.5), (0.4, 0.9), (0.4, 0.1)],
            'I': [(0.15, 0.9), (0.35, 0.9), (0.25, 0.9), (0.25, 0.1), (0.15, 0.1), (0.35, 0.1)],
            'J': [(0.1, 0.9), (0.4, 0.9), (0.4, 0.3), (0.3, 0.1), (0.2, 0.1), (0.1, 0.2)],
            'K': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.4, 0.9), (0.1, 0.5), (0.4, 0.1)],
            'L': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.1)],
            'M': [(0.1, 0.9), (0.1, 0.1), (0.25, 0.5), (0.4, 0.9), (0.4, 0.1)],
            'N': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.9), (0.4, 0.1)],
            'O': [(0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.3, 0.1), (0.4, 0.3), (0.4, 0.7), (0.3, 0.9), (0.2, 0.9)],
            'P': [(0.1, 0.9), (0.1, 0.1), (0.3, 0.9), (0.4, 0.7), (0.3, 0.5), (0.1, 0.5)],
            'Q': [(0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.3, 0.1), (0.4, 0.3), (0.4, 0.7), (0.3, 0.9), (0.2, 0.9), (0.3, 0.2), (0.4, 0.1)],
            'R': [(0.1, 0.9), (0.1, 0.1), (0.3, 0.9), (0.4, 0.7), (0.3, 0.5), (0.1, 0.5), (0.4, 0.1)],
            'S': [(0.4, 0.8), (0.2, 0.9), (0.1, 0.7), (0.2, 0.5), (0.3, 0.5), (0.4, 0.3), (0.3, 0.1), (0.1, 0.2)],
            'T': [(0.1, 0.9), (0.4, 0.9), (0.25, 0.9), (0.25, 0.1)],
            'U': [(0.1, 0.9), (0.1, 0.2), (0.2, 0.1), (0.3, 0.1), (0.4, 0.2), (0.4, 0.9)],
            'V': [(0.1, 0.9), (0.25, 0.1), (0.4, 0.9)],
            'W': [(0.1, 0.9), (0.15, 0.1), (0.25, 0.5), (0.35, 0.1), (0.4, 0.9)],
            'X': [(0.1, 0.9), (0.4, 0.1), (0.25, 0.5), (0.1, 0.1), (0.4, 0.9)],
            'Y': [(0.1, 0.9), (0.25, 0.5), (0.4, 0.9), (0.25, 0.5), (0.25, 0.1)],
            'Z': [(0.1, 0.9), (0.4, 0.9), (0.1, 0.1), (0.4, 0.1)],
            
            # Русские буквы
            'А': [(0.1, 0.9), (0.25, 0.1), (0.4, 0.9), (0.15, 0.6), (0.35, 0.6)],
            'Б': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.3, 0.5), (0.3, 0.1), (0.1, 0.9), (0.3, 0.9)],
            'В': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.3, 0.5), (0.1, 0.5), (0.3, 0.1), (0.3, 0.9)],
            'Г': [(0.1, 0.9), (0.4, 0.9), (0.1, 0.9), (0.1, 0.1)],
            'Д': [(0.1, 0.9), (0.1, 0.1), (0.3, 0.2), (0.35, 0.8), (0.1, 0.9), (0.4, 0.9), (0.4, 0.1)],
            'Е': [(0.4, 0.9), (0.1, 0.9), (0.1, 0.1), (0.4, 0.1), (0.1, 0.5), (0.3, 0.5)],
            'Ё': [(0.4, 0.9), (0.1, 0.9), (0.1, 0.1), (0.4, 0.1), (0.1, 0.5), (0.3, 0.5), (0.15, 0.95), (0.35, 0.95)],
            'Ж': [(0.1, 0.9), (0.25, 0.5), (0.4, 0.9), (0.25, 0.5), (0.25, 0.1), (0.1, 0.1), (0.4, 0.1)],
            'З': [(0.4, 0.8), (0.2, 0.9), (0.3, 0.5), (0.2, 0.1), (0.4, 0.2)],
            'И': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.9), (0.4, 0.1)],
            'Й': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.9), (0.4, 0.1), (0.2, 0.95), (0.3, 0.95)],
            'К': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.4, 0.9), (0.1, 0.5), (0.4, 0.1)],
            'Л': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.1), (0.4, 0.9)],
            'М': [(0.1, 0.9), (0.1, 0.1), (0.25, 0.5), (0.4, 0.9), (0.4, 0.1)],
            'Н': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.4, 0.5), (0.4, 0.9), (0.4, 0.1)],
            'О': [(0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.3, 0.1), (0.4, 0.3), (0.4, 0.7), (0.3, 0.9), (0.2, 0.9)],
            'П': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.9), (0.4, 0.1)],
            'Р': [(0.1, 0.9), (0.1, 0.1), (0.3, 0.9), (0.4, 0.7), (0.3, 0.5), (0.1, 0.5)],
            'С': [(0.4, 0.8), (0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.4, 0.2)],
            'Т': [(0.1, 0.9), (0.4, 0.9), (0.25, 0.9), (0.25, 0.1)],
            'У': [(0.1, 0.9), (0.25, 0.4), (0.4, 0.9), (0.25, 0.4), (0.1, 0.1)],
            'Ф': [(0.25, 0.9), (0.1, 0.7), (0.1, 0.3), (0.25, 0.1), (0.4, 0.3), (0.4, 0.7), (0.25, 0.9), (0.25, 0.05)],
            'Х': [(0.1, 0.9), (0.4, 0.1), (0.25, 0.5), (0.1, 0.1), (0.4, 0.9)],
            'Ц': [(0.1, 0.9), (0.1, 0.1), (0.4, 0.1), (0.4, 0.9), (0.4, 0.1), (0.45, 0.05)],
            'Ч': [(0.1, 0.9), (0.1, 0.5), (0.4, 0.5), (0.4, 0.9), (0.4, 0.1)],
            'Ш': [(0.1, 0.9), (0.1, 0.1), (0.25, 0.1), (0.25, 0.9), (0.25, 0.1), (0.4, 0.1), (0.4, 0.9)],
            'Щ': [(0.1, 0.9), (0.1, 0.1), (0.25, 0.1), (0.25, 0.9), (0.25, 0.1), (0.4, 0.1), (0.4, 0.9), (0.4, 0.1), (0.45, 0.05)],
            'Ъ': [(0.1, 0.9), (0.25, 0.9), (0.25, 0.1), (0.25, 0.5), (0.4, 0.5), (0.4, 0.1)],
            'Ы': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.25, 0.5), (0.25, 0.1), (0.4, 0.9), (0.4, 0.1)],
            'Ь': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.3, 0.5), (0.4, 0.3), (0.3, 0.1), (0.1, 0.1)],
            'Э': [(0.1, 0.8), (0.3, 0.9), (0.4, 0.5), (0.3, 0.1), (0.1, 0.2), (0.25, 0.5)],
            'Ю': [(0.1, 0.9), (0.1, 0.1), (0.1, 0.5), (0.25, 0.5), (0.3, 0.7), (0.3, 0.3), (0.4, 0.1), (0.4, 0.9)],
            'Я': [(0.4, 0.9), (0.1, 0.9), (0.1, 0.6), (0.4, 0.6), (0.4, 0.1), (0.25, 0.6), (0.1, 0.1)],
            
            # Цифры
            '0': [(0.2, 0.9), (0.1, 0.7), (0.1, 0.3), (0.2, 0.1), (0.3, 0.1), (0.4, 0.3), (0.4, 0.7), (0.3, 0.9), (0.2, 0.9)],
            '1': [(0.2, 0.9), (0.25, 0.9), (0.25, 0.1), (0.15, 0.1), (0.35, 0.1)],
            '2': [(0.1, 0.8), (0.3, 0.9), (0.4, 0.7), (0.1, 0.3), (0.1, 0.1), (0.4, 0.1)],
            '3': [(0.1, 0.8), (0.3, 0.9), (0.4, 0.7), (0.2, 0.5), (0.4, 0.3), (0.3, 0.1), (0.1, 0.2)],
            '4': [(0.1, 0.9), (0.1, 0.5), (0.4, 0.5), (0.3, 0.9), (0.3, 0.1)],
            '5': [(0.4, 0.9), (0.1, 0.9), (0.1, 0.6), (0.3, 0.6), (0.4, 0.4), (0.4, 0.2), (0.3, 0.1), (0.1, 0.2)],
            '6': [(0.3, 0.9), (0.1, 0.7), (0.1, 0.2), (0.3, 0.1), (0.4, 0.3), (0.3, 0.5), (0.1, 0.5)],
            '7': [(0.1, 0.9), (0.4, 0.9), (0.2, 0.1)],
            '8': [(0.25, 0.9), (0.1, 0.8), (0.1, 0.6), (0.25, 0.5), (0.4, 0.6), (0.4, 0.8), (0.25, 0.9), (0.25, 0.5), (0.1, 0.4), (0.1, 0.2), (0.25, 0.1), (0.4, 0.2), (0.4, 0.4), (0.25, 0.5)],
            '9': [(0.4, 0.5), (0.25, 0.5), (0.1, 0.3), (0.1, 0.7), (0.25, 0.9), (0.4, 0.7), (0.4, 0.2), (0.25, 0.1)]
        }
        
        return shapes.get(letter, [(0.1, 0.9), (0.1, 0.1)])  # Простая линия по умолчанию
    
    def _calculate_letter_cross_section(self, letter_shape: List[Tuple[float, float]], progress: float) -> List[Tuple[float, float]]:
        """
        Рассчитывает поперечное сечение буквы на заданной позиции
        progress: 0.0 (начало буквы) - 1.0 (конец буквы)
        """
        cross_sections = []
        
        # Интерполируем между точками векторной формы
        for i in range(0, len(letter_shape) - 1, 2):
            if i + 1 < len(letter_shape):
                start_point = letter_shape[i]
                end_point = letter_shape[i + 1]
                
                # Рассчитываем Y-координаты для текущей позиции
                y1 = start_point[1] + (end_point[1] - start_point[1]) * progress
                y2 = end_point[1] + (start_point[1] - end_point[1]) * (1 - progress)
                
                # Добавляем небольшую вариацию для естественности
                variation = math.sin(progress * math.pi * 2) * 0.05
                y1 = max(0.05, min(0.95, y1 + variation))
                y2 = max(0.05, min(0.95, y2 - variation))
                
                # Упорядочиваем координаты
                if y1 > y2:
                    y1, y2 = y2, y1
                
                # Добавляем только значимые сечения
                if y2 - y1 > 0.02:  # минимум 2% от высоты
                    cross_sections.append((y1, y2))
        
        return cross_sections
    
    def calculate_statistics(self, pattern: List[Dict]) -> Dict:
        """Рассчитывает статистику паттерна"""
        if not pattern:
            return {
                'total_folds': 0,
                'pages_used': 0,
                'estimated_time_minutes': 0
            }
        
        total_folds = len(pattern)
        pages_used = len(set(fold['page'] for fold in pattern))
        
        # Более точная оценка времени (40 секунд на сгиб)
        estimated_time = math.ceil(total_folds * 0.67)
        
        return {
            'total_folds': total_folds,
            'pages_used': pages_used,
            'estimated_time_minutes': estimated_time
        }